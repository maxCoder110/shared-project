<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON VOID: OVERDRIVE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        
        /* HUD Styles */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .hud-text {
            position: absolute; color: #fff; text-shadow: 0 0 10px #fff, 0 0 20px #ff00de;
            font-weight: bold; letter-spacing: 2px;
        }
        
        #score-display { top: 20px; left: 20px; font-size: 24px; }
        #highscore-display { top: 20px; right: 20px; font-size: 18px; color: #ffd700; text-shadow: 0 0 10px #ffd700; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20; pointer-events: auto;
        }
        
        h1 {
            font-size: 80px; color: transparent; -webkit-text-stroke: 2px #00ffff;
            text-shadow: 0 0 30px #00ffff; margin: 0; font-style: italic; text-transform: uppercase;
        }
        
        h2 { color: #ff00de; text-shadow: 0 0 15px #ff00de; margin-bottom: 40px; font-size: 24px; }
        
        button {
            background: transparent; border: 2px solid #00ffff; color: #00ffff;
            padding: 15px 50px; font-size: 24px; font-family: inherit; cursor: pointer;
            text-transform: uppercase; transition: 0.2s;
            box-shadow: 0 0 15px #00ffff;
        }
        button:hover { background: #00ffff; color: #000; box-shadow: 0 0 40px #00ffff; }
        
        #controls-hint { position: absolute; bottom: 20px; color: #666; font-size: 14px; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div id="score-display">SCORE: <span id="score">0</span></div>
        <div id="highscore-display">BEST: <span id="highscore">0</span></div>
    </div>

    <div id="overlay">
        <h1>Neon Void</h1>
        <h2>OVERDRIVE</h2>
        <button id="start-btn">INITIALIZE</button>
        <div id="controls-hint">MOUSE / TOUCH TO STEER</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- AUDIO ENGINE (Procedural Sound) ---
        // We create sound using math (Oscillators) so no external files are needed.
        const Audio = {
            ctx: null,
            masterGain: null,
            
            init: function() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3; // Master volume
                this.masterGain.connect(this.ctx.destination);
            },

            playTone: function(freq, type, duration) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            playCollect: function() {
                this.playTone(880, 'sine', 0.1);
                setTimeout(() => this.playTone(1760, 'square', 0.2), 50);
            },

            playCrash: function() {
                if (!this.ctx) return;
                // White noise burst
                const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 seconds
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                noise.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            },

            startEngine: function() {
                if (!this.ctx) return;
                // Low drone
                this.engineOsc = this.ctx.createOscillator();
                this.engineOsc.type = 'sawtooth';
                this.engineOsc.frequency.value = 100;
                this.engineGain = this.ctx.createGain();
                this.engineGain.gain.value = 0.05;
                this.engineOsc.connect(this.engineGain);
                this.engineGain.connect(this.masterGain);
                this.engineOsc.start();
            },

            updateEngine: function(speedNormalized) {
                if (this.engineOsc) {
                    // Pitch up engine as game gets faster
                    this.engineOsc.frequency.value = 60 + (speedNormalized * 100);
                }
            }
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03); // Black fog

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 8);
        camera.lookAt(0, 0, -10);

        const renderer = new THREE.WebGLRenderer({ antialias: false }); // False because Bloom handles AA feeling
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance optimization
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- POST PROCESSING (THE GLOW) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 2.0; // Intense glow
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- OBJECTS ---
        
        // 1. The Grid (Retrowave Floor)
        const gridHelper = new THREE.GridHelper(200, 100, 0xff00de, 0x220044);
        gridHelper.position.y = -1;
        gridHelper.position.z = -50;
        // Stretch it to look endless
        gridHelper.scale.z = 5; 
        scene.add(gridHelper);

        const movingGrid = new THREE.GridHelper(200, 20, 0x00ffff, 0x00ffff);
        movingGrid.position.y = -1;
        movingGrid.scale.z = 2;
        scene.add(movingGrid);

        // 2. The Ship (Built from primitives)
        const shipGroup = new THREE.Group();
        
        // Main body
        const bodyGeo = new THREE.ConeGeometry(0.5, 2, 4);
        const bodyMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black body
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.rotation.x = Math.PI / 2;
        body.rotation.y = Math.PI / 4;
        
        // Glowing edges (Wireframe)
        const wireGeo = new THREE.EdgesGeometry(bodyGeo);
        const wireMat = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const wire = new THREE.LineSegments(wireGeo, wireMat);
        wire.rotation.copy(body.rotation);
        
        // Engine glow
        const engineGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const engineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const engine = new THREE.Mesh(engineGeo, engineMat);
        engine.position.z = 1;

        shipGroup.add(body);
        shipGroup.add(wire);
        shipGroup.add(engine);
        scene.add(shipGroup);

        // 3. Warp Stars (Speed effect)
        const starGeo = new THREE.BufferGeometry();
        const starCount = 500;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount * 3; i++) {
            starPos[i] = (Math.random() - 0.5) * 100;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- GAME LOGIC ---
        let gameRunning = false;
        let speed = 0;
        let baseSpeed = 0.5;
        let score = 0;
        let highscore = localStorage.getItem('neon_highscore') || 0;
        let time = 0;
        
        // Object Pools
        const obstacles = [];
        const coins = [];
        const particles = [];

        document.getElementById('highscore').innerText = highscore;

        // Input
        let mouseX = 0;
        const handleInput = (x) => {
            mouseX = (x / window.innerWidth) * 2 - 1;
        };
        document.addEventListener('mousemove', (e) => handleInput(e.clientX));
        document.addEventListener('touchmove', (e) => handleInput(e.touches[0].clientX), {passive: false});

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('overlay').style.display = 'none';
            Audio.init();
            Audio.startEngine();
            resetGame();
        });

        function spawnObstacle() {
            const geo = new THREE.BoxGeometry(1, 5, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff00de }); // Pink
            const obs = new THREE.Mesh(geo, mat);
            
            // Glowing edges
            const edges = new THREE.LineSegments(
                new THREE.EdgesGeometry(geo),
                new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            obs.add(edges);

            obs.position.set((Math.random() - 0.5) * 20, 0, -100);
            scene.add(obs);
            obstacles.push(obs);
        }

        function spawnCoin() {
            const geo = new THREE.OctahedronGeometry(0.5);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffd700 }); // Gold
            const coin = new THREE.Mesh(geo, mat);
            coin.position.set((Math.random() - 0.5) * 20, 0.5, -100);
            scene.add(coin);
            coins.push(coin);
        }

        function createExplosion(pos, color) {
            for(let i=0; i<20; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                p.userData.vel = new THREE.Vector3(
                    (Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)
                ).normalize().multiplyScalar(0.5);
                scene.add(p);
                particles.push(p);
            }
        }

        function resetGame() {
            gameRunning = true;
            speed = baseSpeed;
            score = 0;
            document.getElementById('score').innerText = score;
            
            // Clear scene items
            obstacles.forEach(o => scene.remove(o));
            coins.forEach(c => scene.remove(c));
            obstacles.length = 0;
            coins.length = 0;

            shipGroup.position.set(0, 0, 0);
            shipGroup.visible = true;
            shipGroup.rotation.z = 0;
        }

        function gameOver() {
            gameRunning = false;
            Audio.playCrash();
            shipGroup.visible = false;
            createExplosion(shipGroup.position, 0x00ffff);
            
            if (score > highscore) {
                highscore = score;
                localStorage.setItem('neon_highscore', highscore);
                document.getElementById('highscore').innerText = highscore;
            }

            setTimeout(() => {
                document.getElementById('overlay').style.display = 'flex';
                document.querySelector('#overlay h2').innerText = "SYSTEM CRASHED";
                document.querySelector('#start-btn').innerText = "REBOOT";
            }, 1500);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 1. Dynamic World Colors
            const hue = (time * 0.1) % 1;
            const color = new THREE.Color().setHSL(hue, 0.5, 0.1); // Dark BG cycling
            scene.fog.color.lerp(color, 0.05);
            // gridHelper.material.color.setHSL(hue, 1, 0.5);

            if (gameRunning) {
                // Increase speed slowly
                speed += 0.0001;
                Audio.updateEngine(speed - baseSpeed); // Update sound pitch

                // Ship Movement
                const targetX = mouseX * 8;
                shipGroup.position.x += (targetX - shipGroup.position.x) * 0.1;
                // Banking
                shipGroup.rotation.z = -(shipGroup.position.x - targetX) * 0.15;
                // Engine wobble
                shipGroup.position.y = Math.sin(time * 20) * 0.05;

                // Move Floor Grid (Parallax illusion)
                movingGrid.position.z += speed;
                if(movingGrid.position.z > 10) movingGrid.position.z = -10;

                // Move Stars
                const positions = stars.geometry.attributes.position.array;
                for(let i=2; i<positions.length; i+=3) {
                    positions[i] += speed * 10;
                    if(positions[i] > 10) positions[i] = -100;
                }
                stars.geometry.attributes.position.needsUpdate = true;

                // Spawn Logic
                if (Math.random() < 0.03) spawnObstacle();
                if (Math.random() < 0.01) spawnCoin();

                // Update Obstacles
                const shipBox = new THREE.Box3().setFromObject(shipGroup);
                shipBox.expandByScalar(-0.3); // Forgiving hitbox

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    let o = obstacles[i];
                    o.position.z += speed;
                    
                    if (shipBox.intersectsBox(new THREE.Box3().setFromObject(o))) {
                        gameOver();
                    }

                    if (o.position.z > 5) {
                        scene.remove(o);
                        obstacles.splice(i, 1);
                        score += 10;
                        document.getElementById('score').innerText = score;
                    }
                }

                // Update Coins
                for (let i = coins.length - 1; i >= 0; i--) {
                    let c = coins[i];
                    c.position.z += speed;
                    c.rotation.x += 0.05;
                    c.rotation.y += 0.05;

                    if (shipBox.intersectsBox(new THREE.Box3().setFromObject(c))) {
                        scene.remove(c);
                        coins.splice(i, 1);
                        score += 50;
                        Audio.playCollect();
                        document.getElementById('score').innerText = score;
                        // Visual feedback
                        createExplosion(c.position, 0xffd700);
                    } else if (c.position.z > 5) {
                        scene.remove(c);
                        coins.splice(i, 1);
                    }
                }
            }

            // Update Particles (Explosions) always
            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i];
                p.position.add(p.userData.vel);
                p.rotation.x += 0.1;
                p.scale.multiplyScalar(0.9);
                if(p.scale.x < 0.01) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            // Render with Bloom
            composer.render();
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>