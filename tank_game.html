<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON WARFARE SAGA: POWER UP UPDATE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* --- UI LAYERS --- */
        .full-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; }
        
        /* MENU SCREEN */
        #menu-screen { display: flex; background: linear-gradient(135deg, #050011 0%, #110022 100%); z-index: 50; }
        .logo { font-size: 80px; color: transparent; -webkit-text-stroke: 2px #00ffff; text-shadow: 0 0 40px #00ffff; font-style: italic; font-weight: 900; margin-bottom: 20px; text-align: center; }
        .subtitle { color: #ff00ff; font-size: 24px; letter-spacing: 10px; margin-bottom: 50px; text-shadow: 0 0 10px #ff00ff; }
        
        /* TANK HUD */
        #tank-hud { display: none; pointer-events: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        #score-box { position: absolute; top: 20px; left: 20px; font-size: 24px; color: #fff; text-shadow: 0 0 10px #fff; }
        #health-bar-container { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%) skew(-20deg); width: 300px; height: 20px; border: 2px solid #ff0000; background: #220000; }
        #health-fill { width: 100%; height: 100%; background: #ff0000; transition: width 0.2s; }
        
        #powerup-text { 
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); 
            font-size: 24px; font-weight: bold; text-shadow: 0 0 10px currentColor; display: none;
        }

        #boss-hud { display: none; position: absolute; top: 20px; right: 20px; width: 300px; text-align: right; }
        #boss-name { color: #ffaa00; font-size: 20px; font-weight: 900; text-shadow: 0 0 10px #ffaa00; }
        #boss-bar-bg { width: 100%; height: 15px; background: #330000; border: 1px solid #ffaa00; margin-top: 5px; }
        #boss-bar-fill { width: 100%; height: 100%; background: #ffaa00; transition: width 0.1s; }

        /* TRON HUD */
        #tron-hud { display: none; pointer-events: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        .tron-title { position: absolute; top: 20px; width: 100%; text-align: center; color: #00ffff; font-size: 30px; letter-spacing: 5px; text-shadow: 0 0 20px #00ffff; }
        .tron-controls { position: absolute; bottom: 20px; width: 100%; text-align: center; color: #aaa; font-size: 18px; }

        /* END SCREENS */
        #game-over-screen { background: rgba(20, 0, 0, 0.95); z-index: 60; }
        #victory-screen { background: rgba(0, 20, 20, 0.95); z-index: 60; }
        
        /* BUTTONS */
        button {
            background: transparent; border: 3px solid #00ffff; color: #00ffff;
            padding: 20px 60px; font-size: 24px; font-weight: bold; cursor: pointer;
            text-transform: uppercase; transition: 0.2s; box-shadow: 0 0 15px #00ffff;
            font-family: inherit; margin-top: 20px;
        }
        button:hover { background: #00ffff; color: #000; box-shadow: 0 0 50px #00ffff; }
        button.restart { border-color: #ff0055; color: #ff0055; box-shadow: 0 0 15px #ff0055; }
        button.restart:hover { background: #ff0055; color: #fff; box-shadow: 0 0 50px #ff0055; }

        .dmg-flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent, red); opacity: 0; transition: opacity 0.1s; pointer-events: none; z-index: 5; }
    </style>
</head>
<body>

    <!-- MENUS -->
    <div id="menu-screen" class="full-screen">
        <div class="logo">NEON WARFARE</div>
        <div class="subtitle">SAGA EDITION</div>
        <button id="btn-start">INITIATE SYSTEM</button>
    </div>

    <div id="game-over-screen" class="full-screen">
        <h1 style="color: #ff0055; font-size: 60px; text-shadow: 0 0 30px red;">SYSTEM FAILURE</h1>
        <h2 id="death-reason" style="color: #fff;">KIA</h2>
        <button class="restart" onclick="location.reload()">REBOOT</button>
    </div>

    <div id="victory-screen" class="full-screen">
        <h1 style="color: #00ff00; font-size: 80px; text-shadow: 0 0 50px #00ff00;">VICTORY</h1>
        <h2 style="color: #fff;">SYSTEM CORE SECURED</h2>
        <button onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <!-- HUDs -->
    <div id="tank-hud">
        <div id="score-box">KILLS: <span id="score">0</span></div>
        <div id="health-bar-container"><div id="health-fill"></div></div>
        <div id="powerup-text">TRIPLE SHOT ACTIVE</div>
        <div id="boss-hud">
            <div id="boss-name">TARGET DETECTED</div>
            <div id="boss-bar-bg"><div id="boss-bar-fill"></div></div>
        </div>
        <div class="dmg-flash" id="dmg-flash"></div>
    </div>

    <div id="tron-hud">
        <div class="tron-title">/// HYPER-CYCLE MODE ///</div>
        <div class="tron-controls">USE ARROW KEYS TO TURN</div>
    </div>

    <!-- MAIN SCRIPT -->
    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.160.0';
        import { EffectComposer } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js?deps=three@0.160.0';
        import { RenderPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/RenderPass.js?deps=three@0.160.0';
        import { UnrealBloomPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js?deps=three@0.160.0';

        // --- GLOBAL MANAGERS ---
        const Audio = {
            ctx: null,
            init: function() {
                const AC = window.AudioContext || window.webkitAudioContext;
                if(!this.ctx) this.ctx = new AC();
                if(this.ctx.state === 'suspended') this.ctx.resume();
            },
            play: function(freq, type, dur, vol=0.1) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + dur);
            }
        };

        const App = {
            mode: 'MENU',
            renderer: null,
            composer: null,
            
            init: function() {
                this.renderer = new THREE.WebGLRenderer({ antialias: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
                
                document.getElementById('menu-screen').style.display = 'flex';
                document.getElementById('btn-start').addEventListener('click', () => {
                    Audio.init();
                    this.startTankGame();
                });

                window.addEventListener('resize', () => this.onResize());
                this.loop();
            },

            startTankGame: function() {
                this.mode = 'TANK';
                document.getElementById('menu-screen').style.display = 'none';
                document.getElementById('tank-hud').style.display = 'block';
                TankGame.init();
            },

            startTronGame: function() {
                this.mode = 'TRON';
                document.getElementById('tank-hud').style.display = 'none';
                document.getElementById('tron-hud').style.display = 'block';
                TronGame.init();
            },

            gameOver: function(reason) {
                this.mode = 'OVER';
                document.getElementById('death-reason').innerText = reason;
                document.getElementById('game-over-screen').style.display = 'flex';
            },

            victory: function() {
                this.mode = 'WIN';
                document.getElementById('victory-screen').style.display = 'flex';
            },

            loop: function() {
                requestAnimationFrame(() => this.loop());
                if (this.mode === 'TANK') TankGame.update(this.renderer, this.composer);
                if (this.mode === 'TRON') TronGame.update(this.renderer);
            },

            onResize: function() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                if(this.mode === 'TANK') TankGame.resize();
                if(this.mode === 'TRON') TronGame.resize();
            }
        };

        // ==========================================
        // === GAME 1: NEON WARFARE (TANK SHOOTER) ===
        // ==========================================
        const TankGame = {
            scene: null, camera: null, composer: null,
            state: { 
                active: false, level: 1, score: 0, health: 100, speed: 0.4, mouseX: 0, 
                bossActive: false, bossHP: 0, bossMaxHP: 0,
                tripleShot: false, shield: false
            },
            assets: { player: null, boss: null, enemies: [], pBullets: [], eBullets: [], particles: [], powerups: [] },
            
            init: function() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x110505, 0.02);
                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 6, 12);
                this.camera.lookAt(0,0,-10);

                this.composer = new EffectComposer(App.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.strength = 1.5; bloom.radius = 0.5;
                this.composer.addPass(bloom);

                const amb = new THREE.AmbientLight(0xffffff, 0.4);
                const dir = new THREE.DirectionalLight(0xffaa00, 1);
                dir.position.set(10, 20, 10);
                this.scene.add(amb, dir);

                const grid = new THREE.GridHelper(300, 60, 0xff0000, 0x330000);
                grid.position.y = -1; grid.scale.z = 5;
                this.scene.add(grid);
                this.grid = grid;

                const pGroup = new THREE.Group();
                const chassis = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 2), new THREE.MeshPhongMaterial({color:0x00ff00}));
                const turret = new THREE.Mesh(new THREE.BoxGeometry(1, 0.6, 1), new THREE.MeshPhongMaterial({color:0x00aa00}));
                turret.position.y = 0.5;
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), new THREE.MeshPhongMaterial({color:0x222222}));
                barrel.rotation.x = Math.PI/2; barrel.position.set(0, 0.6, -1);
                pGroup.add(chassis, turret, barrel);
                this.scene.add(pGroup);
                this.assets.player = pGroup;

                document.addEventListener('mousemove', e => this.state.mouseX = (e.clientX/window.innerWidth)*2-1);
                const fire = () => { if(App.mode === 'TANK') this.shoot(); };
                window.addEventListener('mousedown', fire);
                window.addEventListener('keydown', e => { if(e.code==='Space') fire(); });

                this.state.active = true;
            },

            shoot: function() {
                Audio.play(400, 'square', 0.1);
                const spawnBullet = (offset) => {
                    const b = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 2), new THREE.MeshBasicMaterial({color:0x00ff00}));
                    b.position.copy(this.assets.player.position);
                    b.position.x += offset;
                    b.position.y = 0.5;
                    this.scene.add(b);
                    this.assets.pBullets.push(b);
                };

                spawnBullet(0);
                if (this.state.tripleShot) {
                    spawnBullet(-1);
                    spawnBullet(1);
                }
            },

            spawnPowerup: function() {
                const rand = Math.random();
                let type, color, geo;
                
                if (rand < 0.4) {
                    type = 'health'; color = 0x00ff00; // Green Box
                    geo = new THREE.BoxGeometry(1, 1, 1);
                } else if (rand < 0.8) {
                    type = 'triple'; color = 0x00ffff; // Cyan Octahedron
                    geo = new THREE.OctahedronGeometry(0.8);
                } else {
                    type = 'shield'; color = 0xffff00; // Yellow Sphere
                    geo = new THREE.IcosahedronGeometry(0.8);
                }

                const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color: color, wireframe: true}));
                // Core
                const core = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshBasicMaterial({color: 0xffffff}));
                mesh.add(core);

                mesh.position.set((Math.random()-0.5)*25, 1, -120);
                mesh.userData = { type: type, color: color };
                
                this.scene.add(mesh);
                this.assets.powerups.push(mesh);
            },

            activatePowerup: function(type, color) {
                const txt = document.getElementById('powerup-text');
                txt.style.display = 'block';
                txt.style.color = '#' + new THREE.Color(color).getHexString();
                Audio.play(600, 'sine', 0.2);

                if (type === 'health') {
                    this.state.health = Math.min(100, this.state.health + 30);
                    document.getElementById('health-fill').style.width = this.state.health + '%';
                    txt.innerText = "REPAIRED";
                    setTimeout(() => txt.style.display = 'none', 1000);
                } 
                else if (type === 'triple') {
                    this.state.tripleShot = true;
                    txt.innerText = "TRIPLE SHOT ACTIVE";
                    setTimeout(() => {
                        this.state.tripleShot = false;
                        if(txt.innerText.includes("TRIPLE")) txt.style.display = 'none';
                    }, 10000);
                }
                else if (type === 'shield') {
                    this.state.shield = true;
                    txt.innerText = "SHIELD ACTIVE";
                    this.assets.player.children.forEach(c => c.material.emissive = new THREE.Color(0xffff00));
                    setTimeout(() => {
                        this.state.shield = false;
                        this.assets.player.children.forEach(c => c.material.emissive = new THREE.Color(0x000000));
                        if(txt.innerText.includes("SHIELD")) txt.style.display = 'none';
                    }, 5000);
                }
            },

            spawnBoss: function() {
                this.state.bossActive = true;
                let hp, color, type;
                if (this.state.level === 1) { hp = 300; color = 0xff0000; type='HK-PHANTOM'; }
                else if (this.state.level === 2) { hp = 600; color = 0x00ff00; type='IRON-STRIDER'; }
                else { hp = 1000; color = 0x0000ff; type='OMEGA-CORE'; }

                this.state.bossMaxHP = hp;
                this.state.bossHP = hp;
                const boss = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 3), new THREE.MeshPhongMaterial({color:color}));
                boss.add(body);
                boss.position.set(0, 15, -150); 
                boss.userData = { type: type };
                this.scene.add(boss);
                this.assets.boss = boss;
                document.getElementById('boss-hud').style.display = 'block';
                document.getElementById('boss-name').innerText = type;
                document.getElementById('boss-bar-fill').style.width = '100%';
            },

            spawnEnemy: function() {
                const grp = new THREE.Group();
                const isTank = Math.random() > 0.5;
                const mat = new THREE.MeshPhongMaterial({color: 0xaa0000});

                if (isTank) {
                    // Tank Model
                    const chassis = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1, 3), mat);
                    chassis.position.y = 0.5;
                    const turret = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 2), mat);
                    turret.position.y = 1.4;
                    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2.5), mat);
                    barrel.rotation.x = Math.PI / 2;
                    barrel.position.set(0, 1.4, 1.5);
                    const treadL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 3), new THREE.MeshPhongMaterial({color: 0x550000}));
                    treadL.position.set(-1.5, 0.5, 0);
                    const treadR = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 3), new THREE.MeshPhongMaterial({color: 0x550000}));
                    treadR.position.set(1.5, 0.5, 0);
                    grp.add(chassis, turret, barrel, treadL, treadR);
                    grp.userData = { hp: 3 + this.state.level, type: 'tank', shootTimer: Math.random() * 100 + 50 };
                } else {
                    // Soldier Model
                    const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1, 0.4), mat);
                    body.position.y = 1;
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.3), mat);
                    head.position.y = 1.65;
                    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1, 0.25), mat);
                    legL.position.set(-0.2, 0.5, 0);
                    const legR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1, 0.25), mat);
                    legR.position.set(0.2, 0.5, 0);
                    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), mat);
                    armL.position.set(-0.4, 1.2, 0);
                    const armR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), mat);
                    armR.position.set(0.4, 1.2, 0);
                    const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.8), new THREE.MeshPhongMaterial({color: 0x555555}));
                    gun.position.set(0.4, 1.1, 0.4);
                    grp.add(body, head, legL, legR, armL, armR, gun);
                    grp.userData = { hp: 1 + this.state.level, type: 'soldier', shootTimer: Math.random() * 100 };
                }
                grp.position.set((Math.random()-0.5)*30, 0, -120);
                this.scene.add(grp);
                this.assets.enemies.push(grp);
            },

            shootEnemyBullet: function(enemy) {
                Audio.play(150, 'square', 0.1);
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xff0000}));
                b.position.copy(enemy.position);
                b.position.y += 0.8; 
                b.position.z += 1;
                const dx = (this.assets.player.position.x - enemy.position.x) * 0.03;
                b.userData = { vel: new THREE.Vector3(dx, 0, 0.6) };
                this.scene.add(b);
                this.assets.eBullets.push(b);
            },

            update: function() {
                if(!this.state.active) return;

                // Player Move
                const targetX = this.state.mouseX * 15;
                this.assets.player.position.x += (targetX - this.assets.player.position.x) * 0.1;
                this.assets.player.rotation.y = -(this.assets.player.position.x - targetX) * 0.03;
                
                // Grid Move
                this.state.speed += 0.0001;
                this.grid.position.z += this.state.speed;
                if(this.grid.position.z > 0) this.grid.position.z = -50;

                // Spawning
                if(this.assets.boss) {
                    const b = this.assets.boss;
                    if(b.position.z < -40) { b.position.z += 0.5; b.position.y -= 0.1; }
                    else {
                        b.position.y = 4 + Math.sin(Date.now()*0.002)*2;
                        b.position.x += (this.assets.player.position.x - b.position.x) * 0.05;
                        if(Math.random() < 0.05) {
                            const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0xffaa00}));
                            bullet.position.copy(b.position);
                            const dir = new THREE.Vector3().subVectors(this.assets.player.position, b.position).normalize().multiplyScalar(0.8);
                            bullet.userData = { vel: dir };
                            this.scene.add(bullet);
                            this.assets.eBullets.push(bullet);
                            Audio.play(100, 'sawtooth', 0.2);
                        }
                    }
                } else {
                    if (this.state.score >= this.state.level * 10 && !this.state.bossActive) this.spawnBoss();
                    else if (!this.state.bossActive) {
                        if (Math.random() < 0.02) this.spawnEnemy();
                        if (Math.random() < 0.005) this.spawnPowerup();
                    }
                }

                // Player Bullets
                for(let i=this.assets.pBullets.length-1; i>=0; i--) {
                    const b = this.assets.pBullets[i];
                    b.position.z -= 2;
                    const bBox = new THREE.Box3().setFromObject(b);
                    const vBox = bBox.clone(); vBox.min.y = -100; vBox.max.y = 100;
                    let hit = false;

                    if(this.assets.boss) {
                        const bossBox = new THREE.Box3().setFromObject(this.assets.boss);
                        if(vBox.intersectsBox(bossBox)) {
                            this.createExplosion(b.position);
                            this.state.bossHP -= 10;
                            document.getElementById('boss-bar-fill').style.width = (this.state.bossHP/this.state.bossMaxHP*100)+'%';
                            hit = true;
                            if(this.state.bossHP <= 0) {
                                this.scene.remove(this.assets.boss);
                                this.assets.boss = null;
                                this.state.bossActive = false;
                                document.getElementById('boss-hud').style.display = 'none';
                                if(this.state.level === 3) { this.state.active = false; App.startTronGame(); return; }
                                else { this.state.level++; this.scene.fog.color.setHex(this.state.level===2?0x051105:0x050511); }
                            }
                        }
                    }

                    if(!hit) {
                        for(let j=this.assets.enemies.length-1; j>=0; j--) {
                            const e = this.assets.enemies[j];
                            if(bBox.intersectsBox(new THREE.Box3().setFromObject(e))) {
                                e.userData.hp--;
                                if(e.userData.hp <= 0) {
                                    this.createExplosion(e.position);
                                    this.scene.remove(e); this.assets.enemies.splice(j,1);
                                    this.state.score++;
                                    document.getElementById('score').innerText = this.state.score;
                                }
                                hit = true; break;
                            }
                        }
                    }
                    if(hit || b.position.z < -150) { this.scene.remove(b); this.assets.pBullets.splice(i,1); }
                }

                const pBox = new THREE.Box3().setFromObject(this.assets.player);
                pBox.min.y = -50; pBox.max.y = 50;

                // Enemies
                for(let i=this.assets.enemies.length-1; i>=0; i--) {
                    const e = this.assets.enemies[i];
                    e.position.z += this.state.speed;
                    if (e.position.z > -100 && e.position.z < 0) {
                        e.userData.shootTimer--;
                        if (e.userData.shootTimer <= 0) {
                            this.shootEnemyBullet(e);
                            e.userData.shootTimer = e.userData.type === 'tank' ? 120 : 80; 
                        }
                    }
                    if(pBox.intersectsBox(new THREE.Box3().setFromObject(e))) {
                        this.takeDamage(20);
                        this.scene.remove(e); this.assets.enemies.splice(i,1);
                    } else if(e.position.z > 10) {
                        this.scene.remove(e); this.assets.enemies.splice(i,1);
                    }
                }

                // Enemy Bullets
                for(let i=this.assets.eBullets.length-1; i>=0; i--) {
                    const b = this.assets.eBullets[i];
                    b.position.add(b.userData.vel);
                    if(pBox.containsPoint(b.position)) {
                        this.takeDamage(10);
                        this.scene.remove(b); this.assets.eBullets.splice(i,1);
                    } else if (b.position.z > 20 || b.position.y < -5) {
                        this.scene.remove(b); this.assets.eBullets.splice(i,1);
                    }
                }

                // Powerups
                for(let i=this.assets.powerups.length-1; i>=0; i--) {
                    const p = this.assets.powerups[i];
                    p.position.z += this.state.speed;
                    p.rotation.y += 0.05; p.rotation.z += 0.05;
                    if(pBox.intersectsBox(new THREE.Box3().setFromObject(p))) {
                        this.activatePowerup(p.userData.type, p.userData.color);
                        this.scene.remove(p); this.assets.powerups.splice(i,1);
                    } else if(p.position.z > 10) {
                        this.scene.remove(p); this.assets.powerups.splice(i,1);
                    }
                }

                // Particles
                for(let i=this.assets.particles.length-1; i>=0; i--) {
                    const p = this.assets.particles[i];
                    p.position.add(p.userData.vel);
                    p.scale.multiplyScalar(0.9);
                    if(p.scale.x < 0.05) { this.scene.remove(p); this.assets.particles.splice(i,1); }
                }

                this.composer.render();
            },

            createExplosion: function(pos) {
                Audio.play(200, 'square', 0.1);
                for(let i=0; i<8; i++) {
                    const p = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshBasicMaterial({color:0xffaa00}));
                    p.position.copy(pos);
                    p.userData = { vel: new THREE.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5) };
                    this.scene.add(p);
                    this.assets.particles.push(p);
                }
            },

            takeDamage: function(amt) {
                if (this.state.shield) return; // Invincible
                this.state.health -= amt;
                document.getElementById('health-fill').style.width = this.state.health + '%';
                const flash = document.getElementById('dmg-flash');
                flash.style.opacity = 1;
                setTimeout(() => flash.style.opacity = 0, 100);
                if(this.state.health <= 0) App.gameOver("TANK DESTROYED");
            },

            resize: function() {
                this.camera.aspect = window.innerWidth/window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
        };

        // ==========================================
        // === GAME 2: NEON TRON (LIGHT CYCLE) ===
        // ==========================================
        const TronGame = {
            scene: null, camera: null, composer: null,
            gridSize: 40, cellSize: 2,
            cycles: [], lastTime: 0, tickRate: 80,
            walls: new Set(),

            init: function() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x001111);
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 50, 60);
                this.camera.lookAt(0, 0, 0);

                this.composer = new EffectComposer(App.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.strength = 2.0; bloom.radius = 0.8;
                this.composer.addPass(bloom);

                const gridHelper = new THREE.GridHelper(this.gridSize * this.cellSize, this.gridSize, 0x00ffff, 0x003333);
                this.scene.add(gridHelper);
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshBasicMaterial({color:0x000000}));
                plane.rotation.x = -Math.PI/2; plane.position.y = -0.1;
                this.scene.add(plane);

                this.walls.clear();
                this.cycles = [
                    this.createCycle(0x00ffff, 0, 10, 0, 1, true),
                    this.createCycle(0xff0055, 0, -10, 0, -1, false)
                ];

                window.addEventListener('keydown', e => {
                    if(App.mode !== 'TRON') return;
                    const p = this.cycles[0];
                    if(e.key === 'ArrowUp' && p.dz !== 1) { p.nextDx = 0; p.nextDz = -1; }
                    if(e.key === 'ArrowDown' && p.dz !== -1) { p.nextDx = 0; p.nextDz = 1; }
                    if(e.key === 'ArrowLeft' && p.dx !== 1) { p.nextDx = -1; p.nextDz = 0; }
                    if(e.key === 'ArrowRight' && p.dx !== -1) { p.nextDx = 1; p.nextDz = 0; }
                });
            },

            createCycle: function(color, x, z, dx, dz, isPlayer) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1, 1.8), new THREE.MeshBasicMaterial({color: color}));
                mesh.position.set(x * this.cellSize, 0.5, z * this.cellSize);
                this.scene.add(mesh);
                return {
                    mesh: mesh, color: color, x: x, z: z, dx: dx, dz: dz, nextDx: dx, nextDz: dz,
                    isPlayer: isPlayer, alive: true
                };
            },

            update: function(renderer) {
                const now = Date.now();
                if (now - this.lastTime > this.tickRate) {
                    this.lastTime = now;
                    this.tick();
                }
                this.composer.render();
            },

            tick: function() {
                this.cycles.forEach(c => {
                    if(!c.alive) return;
                    if(!c.isPlayer) this.aiMove(c);
                    c.dx = c.nextDx; c.dz = c.nextDz;
                    this.addWall(c.x, c.z, c.color);
                    c.x += c.dx; c.z += c.dz;
                    c.mesh.position.x = c.x * this.cellSize;
                    c.mesh.position.z = c.z * this.cellSize;

                    if (this.checkCollision(c.x, c.z)) {
                        c.alive = false;
                        this.scene.remove(c.mesh);
                        this.createExplosion(c.mesh.position, c.color);
                        Audio.play(100, 'sawtooth', 0.5);
                        if (c.isPlayer) App.gameOver("DERESOLED");
                        else App.victory();
                    }
                });
            },

            addWall: function(x, z, color) {
                const key = `${x},${z}`;
                this.walls.add(key);
                const wall = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1, 1.8), new THREE.MeshBasicMaterial({color: color}));
                wall.position.set(x * this.cellSize, 0.5, z * this.cellSize);
                this.scene.add(wall);
            },

            checkCollision: function(x, z) {
                const limit = this.gridSize / 2;
                if (x < -limit || x > limit || z < -limit || z > limit) return true;
                if (this.walls.has(`${x},${z}`)) return true;
                return false;
            },

            aiMove: function(c) {
                const nextX = c.x + c.dx;
                const nextZ = c.z + c.dz;
                if (this.checkCollision(nextX, nextZ) || Math.random() < 0.05) {
                    const dirs = [{dx: 0, dz: 1}, {dx: 0, dz: -1}, {dx: 1, dz: 0}, {dx: -1, dz: 0}];
                    const valid = dirs.filter(d => !(d.dx === -c.dx && d.dz === -c.dz));
                    const safe = valid.filter(d => !this.checkCollision(c.x + d.dx, c.z + d.dz));
                    if(safe.length > 0) {
                        const move = safe[Math.floor(Math.random() * safe.length)];
                        c.nextDx = move.dx; c.nextDz = move.dz;
                    }
                }
            },

            createExplosion: function(pos, color) {
                for(let i=0; i<20; i++) {
                    const p = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color:color}));
                    p.position.copy(pos);
                    p.position.x += (Math.random()-0.5)*2;
                    p.position.z += (Math.random()-0.5)*2;
                    this.scene.add(p);
                }
            },

            resize: function() {
                this.camera.aspect = window.innerWidth/window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
        };

        App.init();
    </script>
</body>
</html>