<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Cycle: Grid Wars</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc; pointer-events: none; z-index: 10;
        }
        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 40px; text-align: center; display: none;
            text-shadow: 0 0 20px #ff0055; background: rgba(0,0,0,0.9); padding: 60px; 
            border: 4px solid #ff0055; box-shadow: 0 0 50px #ff0055;
            z-index: 20;
        }
        h1 { margin: 0; font-size: 24px; text-transform: uppercase; letter-spacing: 4px; }
        p { margin: 5px 0; font-size: 18px; }
        .controls { font-size: 14px; color: #888; margin-top: 10px; }
        .blink { animation: blinker 1s linear infinite; color: #ff0055; }
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

<div id="ui">
    <h1>NEON CYCLE</h1>
    <p>Level: <span id="level">1</span></p>
    <p>Score: <span id="score">0</span></p>
    <p>Enemies: <span id="enemies">0</span></p>
    <div class="controls">ARROWS to Turn | SPACE to Boost</div>
</div>

<div id="game-over">
    <div style="font-size: 60px; margin-bottom: 10px;">SYSTEM FAILURE</div>
    <div class="blink">CRITICAL ERROR DETECTED</div>
    <div style="font-size: 20px; margin-top: 30px; color: #fff;">Press ENTER to Reboot</div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

// --- CONFIGURATION ---
const GRID_SIZE = 240; 
const CELL_SIZE = 2; 
const SPEED_NORMAL = 1.0;
const SPEED_BOOST = 1.8;
const COLORS = {
    player: 0x00ffff,
    enemy: 0xff3300,
    wall: 0xaa00aa,
    grid: 0x111111
};

// --- GLOBALS ---
let scene, camera, renderer, composer;
let cycles = [];
let walls = [];
let particles = [];
let gridMap = new Set();
let isGameOver = false;
let level = 1;
let score = 0;
let trailLengthCap = 50; 
let screenShake = 0; // Visual impact variable

// DOM Elements
const uiLevel = document.getElementById('level');
const uiScore = document.getElementById('score');
const uiEnemies = document.getElementById('enemies');
const uiGameOver = document.getElementById('game-over');

// --- SETUP ---
function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.0025);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 140, 120); // Higher camera for better view
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: false }); // False for retro feel
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // POST PROCESSING (The Glow)
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0;
    bloomPass.strength = 1.5; 
    bloomPass.radius = 0.5;
    
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // Floor Grid
    const gridHelper = new THREE.GridHelper(GRID_SIZE * 2, GRID_SIZE / 2, 0x444444, 0x111111);
    scene.add(gridHelper);

    // Boundary
    createBoundary();

    // Lights
    const ambient = new THREE.AmbientLight(0x404040);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(50, 100, 50);
    scene.add(dirLight);

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('keydown', handleInput);
    window.addEventListener('keyup', (e) => {
        if (e.code === 'Space' && cycles[0]) cycles[0].speed = SPEED_NORMAL;
    });

    startLevel();
    animate();
}

// --- GAME LOGIC ---

function startLevel() {
    // 1. Wipe everything existing
    killAllVisuals();
    
    isGameOver = false;
    trailLengthCap = 40 + (level * 20);
    
    // Spawn Player
    const player = new Cycle(0, 0, COLORS.player, true);
    cycles.push(player);

    // Spawn Enemies
    const enemyCount = Math.min(level + 1, 15);
    for(let i=0; i<enemyCount; i++) {
        let ex, ez;
        // Ensure enemies don't spawn on top of player
        do {
            ex = (Math.random() > 0.5 ? 1 : -1) * (20 + Math.random() * 80);
            ez = (Math.random() > 0.5 ? 1 : -1) * (20 + Math.random() * 80);
        } while (Math.abs(ex) < 30 && Math.abs(ez) < 30);
        
        cycles.push(new Cycle(ex, ez, COLORS.enemy, false));
    }

    // Spawn Random Obstacles
    if (level > 0) {
        let wallCount = level * 8;
        for(let i=0; i<wallCount; i++) {
            let wx = Math.floor((Math.random() * GRID_SIZE - GRID_SIZE/2) / CELL_SIZE) * CELL_SIZE;
            let wz = Math.floor((Math.random() * GRID_SIZE - GRID_SIZE/2) / CELL_SIZE) * CELL_SIZE;
            if(Math.abs(wx) < 30 && Math.abs(wz) < 30) continue; 
            createWall(wx, wz);
        }
    }

    updateUI();
}

// Cleans up meshes without explosion logic (used for restart)
function killAllVisuals() {
    cycles.forEach(c => {
        scene.remove(c.mesh);
        c.trailPoints.forEach(t => scene.remove(t.mesh));
    });
    walls.forEach(w => scene.remove(w));
    
    cycles = [];
    walls = [];
    gridMap.clear();
}

class Cycle {
    constructor(x, z, color, isPlayer) {
        this.isPlayer = isPlayer;
        this.color = color;
        this.speed = SPEED_NORMAL;
        this.alive = true;
        this.direction = isPlayer ? 0 : Math.floor(Math.random() * 4);
        this.nextDirection = this.direction;

        // Visuals
        const geometry = new THREE.BoxGeometry(2, 2, 4); 
        const material = new THREE.MeshStandardMaterial({ 
            color: color, 
            emissive: color,
            emissiveIntensity: 3.0
        });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 1, z);
        scene.add(this.mesh);

        this.trailPoints = [];
        this.lastGridPos = { x: Math.round(x), z: Math.round(z) };
    }

    update() {
        if (!this.alive) return;

        // AI Logic
        if (!this.isPlayer) this.aiThink();

        // Rotation
        const targetRot = (this.direction === 0 ? Math.PI : this.direction === 1 ? Math.PI/2 : this.direction === 2 ? 0 : -Math.PI/2);
        this.mesh.rotation.y = targetRot;

        // Movement
        let dist = this.speed;
        let dx = 0, dz = 0;
        if (this.direction === 0) dz = -dist;
        else if (this.direction === 1) dx = dist;
        else if (this.direction === 2) dz = dist;
        else if (this.direction === 3) dx = -dist;

        this.mesh.position.x += dx;
        this.mesh.position.z += dz;

        // Grid Logic
        let currentGridX = Math.round(this.mesh.position.x / CELL_SIZE) * CELL_SIZE;
        let currentGridZ = Math.round(this.mesh.position.z / CELL_SIZE) * CELL_SIZE;

        if (currentGridX !== this.lastGridPos.x || currentGridZ !== this.lastGridPos.z) {
            
            // 1. Check for Walls/Trails
            let key = `${currentGridX},${currentGridZ}`;
            if (gridMap.has(key) || Math.abs(currentGridX) > GRID_SIZE || Math.abs(currentGridZ) > GRID_SIZE) {
                this.die();
                return;
            }

            // 2. Check Head-to-Head
            for(let other of cycles) {
                if(other !== this && other.alive) {
                    if (Math.abs(other.mesh.position.x - this.mesh.position.x) < 2 &&
                        Math.abs(other.mesh.position.z - this.mesh.position.z) < 2) {
                        this.die();
                        other.die();
                        return;
                    }
                }
            }

            // 3. Drop Trail
            this.addTrailSegment(this.lastGridPos.x, this.lastGridPos.z);
            this.lastGridPos = { x: currentGridX, z: currentGridZ };
            gridMap.add(key); 
            this.direction = this.nextDirection;
        }
    }

    addTrailSegment(x, z) {
        const geo = new THREE.BoxGeometry(CELL_SIZE, 2, CELL_SIZE);
        const mat = new THREE.MeshBasicMaterial({ color: this.color, transparent: true, opacity: 0.8 });
        const trailMesh = new THREE.Mesh(geo, mat);
        trailMesh.position.set(x, 1, z);
        scene.add(trailMesh);
        this.trailPoints.push({ x: x, z: z, mesh: trailMesh });

        if (this.trailPoints.length > trailLengthCap) {
            let old = this.trailPoints.shift();
            scene.remove(old.mesh);
            gridMap.delete(`${old.x},${old.z}`);
        }
    }

    aiThink() {
        // Look ahead
        let lookX = this.lastGridPos.x;
        let lookZ = this.lastGridPos.z;
        let step = CELL_SIZE;

        if (this.direction === 0) lookZ -= step;
        else if (this.direction === 1) lookX += step;
        else if (this.direction === 2) lookZ += step;
        else if (this.direction === 3) lookX -= step;

        let blocked = gridMap.has(`${lookX},${lookZ}`) || Math.abs(lookX) > GRID_SIZE || Math.abs(lookZ) > GRID_SIZE;

        if (blocked || Math.random() < 0.05) {
            let possible = [];
            // Check all 4 directions
            const dirs = [
                { id: 0, x: 0, z: -step }, // N
                { id: 1, x: step, z: 0 },  // E
                { id: 2, x: 0, z: step },  // S
                { id: 3, x: -step, z: 0 }  // W
            ];

            dirs.forEach(d => {
                // Don't turn 180
                if (Math.abs(this.direction - d.id) === 2) return;
                
                let k = `${this.lastGridPos.x + d.x},${this.lastGridPos.z + d.z}`;
                if (!gridMap.has(k) && Math.abs(this.lastGridPos.x + d.x) < GRID_SIZE && Math.abs(this.lastGridPos.z + d.z) < GRID_SIZE) {
                    possible.push(d.id);
                }
            });

            if (possible.length > 0) {
                this.nextDirection = possible[Math.floor(Math.random() * possible.length)];
                this.direction = this.nextDirection;
            }
        }
    }

    die() {
        if (!this.alive) return;
        this.alive = false;
        
        createExplosion(this.mesh.position, this.color);
        
        // Remove visuals immediately
        scene.remove(this.mesh);
        this.trailPoints.forEach(p => {
            scene.remove(p.mesh);
            gridMap.delete(`${p.x},${p.z}`); // Clean grid immediately
        });
        this.trailPoints = [];

        // Screen Shake
        screenShake = 1.0; 

        if (this.isPlayer) {
            // TRIGGER MASS EXTINCTION
            endGame();
        } else {
            // If enemy dies, just give score
            if (!isGameOver) {
                score += 100;
                checkLevelComplete();
            }
        }
        updateUI();
    }
}

// --- WORLD GENERATION ---
function createBoundary() {
    const geo = new THREE.BoxGeometry(GRID_SIZE * 2 + 2, 8, 2);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff0055 });
    
    const w1 = new THREE.Mesh(geo, mat); w1.position.z = -GRID_SIZE - 1;
    const w2 = new THREE.Mesh(geo, mat); w2.position.z = GRID_SIZE + 1;
    const w3 = new THREE.Mesh(geo, mat); w3.rotation.y = Math.PI/2; w3.position.x = -GRID_SIZE - 1;
    const w4 = new THREE.Mesh(geo, mat); w4.rotation.y = Math.PI/2; w4.position.x = GRID_SIZE + 1;
    scene.add(w1, w2, w3, w4);
}

function createWall(x, z) {
    const geo = new THREE.BoxGeometry(CELL_SIZE * 3, 6, CELL_SIZE * 3);
    const mat = new THREE.MeshLambertMaterial({ color: COLORS.wall });
    const wall = new THREE.Mesh(geo, mat);
    wall.position.set(x, 3, z);
    scene.add(wall);
    walls.push(wall);
    
    // Mark grid
    for(let i=-1; i<=1; i++) {
        for(let j=-1; j<=1; j++) {
            gridMap.add(`${x + i*CELL_SIZE},${z + j*CELL_SIZE}`);
        }
    }
}

function createExplosion(pos, color) {
    const particleCount = 40;
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const velocities = [];

    for (let i = 0; i < particleCount; i++) {
        positions.push(pos.x, pos.y, pos.z);
        // Explosive velocity
        velocities.push(
            (Math.random() - 0.5) * 4,
            (Math.random() - 0.5) * 4,
            (Math.random() - 0.5) * 4
        );
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    const material = new THREE.PointsMaterial({ color: color, size: 2.5, transparent: true });
    const pts = new THREE.Points(geometry, material);
    scene.add(pts);
    particles.push({ mesh: pts, vels: velocities, age: 0 });
}

// --- SYSTEM LOGIC ---

function handleInput(e) {
    if (isGameOver) {
        if (e.code === 'Enter') {
            isGameOver = false;
            level = 1;
            score = 0;
            uiGameOver.style.display = 'none';
            startLevel();
        }
        return;
    }

    const p = cycles[0];
    if (!p || !p.alive) return;

    if (e.code === 'ArrowUp' && p.direction !== 2) p.nextDirection = 0;
    if (e.code === 'ArrowRight' && p.direction !== 3) p.nextDirection = 1;
    if (e.code === 'ArrowDown' && p.direction !== 0) p.nextDirection = 2;
    if (e.code === 'ArrowLeft' && p.direction !== 1) p.nextDirection = 3;
    if (e.code === 'Space') p.speed = SPEED_BOOST;
}

function checkLevelComplete() {
    let enemiesAlive = cycles.filter(c => !c.isPlayer && c.alive).length;
    if (enemiesAlive === 0) {
        level++;
        score += 500;
        // Subtle shake for success
        screenShake = 0.5;
        setTimeout(startLevel, 2000); 
    }
}

function endGame() {
    isGameOver = true;
    uiGameOver.style.display = 'block';
    
    // KILL EVERYONE
    cycles.forEach(c => {
        if(c.alive && !c.isPlayer) {
            c.die(); // Chain reaction explosions
        }
    });
}

function updateUI() {
    uiLevel.innerText = level;
    uiScore.innerText = score;
    uiEnemies.innerText = cycles.filter(c => !c.isPlayer && c.alive).length;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);

    // Camera Shake Decay
    if (screenShake > 0) {
        camera.position.x += (Math.random() - 0.5) * screenShake;
        camera.position.z += (Math.random() - 0.5) * screenShake;
        screenShake *= 0.9; // Fade out shake
    }

    // Particle Updates
    for(let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.age++;
        const pos = p.mesh.geometry.attributes.position.array;
        for(let j=0; j<pos.length; j+=3) {
            pos[j] += p.vels[j];
            pos[j+1] += p.vels[j+1];
            pos[j+2] += p.vels[j+2];
        }
        p.mesh.geometry.attributes.position.needsUpdate = true;
        p.mesh.material.opacity = 1 - (p.age / 50); // Fade out

        if(p.age > 50) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }

    if(!isGameOver) {
        cycles.forEach(c => c.update());
        
        // Smooth follow camera (Only if player exists)
        if (cycles[0] && cycles[0].alive) {
            const pPos = cycles[0].mesh.position;
            // Target Camera Position
            const targetX = pPos.x;
            const targetZ = pPos.z + 80;
            
            // Lerp
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.z += (targetZ - camera.position.z) * 0.1;
            camera.lookAt(pPos.x, 0, pPos.z);
        }
    }

    composer.render();
}

init();

</script>
</body>
</html>